using UnityAssetParser.Bundle;
using UnityAssetParser.SerializedFile;

namespace UnityAssetParser.Tests.SerializedFile;

/// <summary>
/// Integration tests for SerializedFile with BundleFile fixtures.
/// These tests require real Unity asset bundles from R.E.P.O. mods.
/// </summary>
public class SerializedFileIntegrationTests
{
    // NOTE: These tests are placeholders until real fixtures are added
    // Real fixtures should be placed in Tests/Fixtures/Bundles/
    // Expected files: Cigar.hhh, FrogHatSmile.hhh, BambooCopter.hhh

    [Fact(Skip = "Requires real Unity asset bundle fixtures")]
    public void ParseNode0_FromCigarBundle_ContainsMeshObjects()
    {
        // Arrange
        string fixturePath = Path.Combine("Fixtures", "Bundles", "Cigar.hhh");
        
        // This test would:
        // 1. Load Cigar.hhh bundle with BundleFile.Parse()
        // 2. Extract Node 0 (SerializedFile containing object metadata)
        // 3. Parse Node 0 with SerializedFile.Parse()
        // 4. Verify that Mesh objects (ClassID 43) are detected
        // 5. Verify PathIDs are unique
        // 6. Verify object bounds are valid
        
        Assert.True(File.Exists(fixturePath), 
            "Fixture not found. Download Cigar mod from Thunderstore and extract Cigar.hhh to Tests/Fixtures/Bundles/");
    }

    [Fact(Skip = "Requires real Unity asset bundle fixtures")]
    public void ParseNode0_FromFrogHatSmile_ContainsMeshObjects()
    {
        // Arrange
        string fixturePath = Path.Combine("Fixtures", "Bundles", "FrogHatSmile.hhh");
        
        Assert.True(File.Exists(fixturePath), 
            "Fixture not found. Download FrogHatSmile mod from Thunderstore and extract to Tests/Fixtures/Bundles/");
    }

    [Fact(Skip = "Requires real Unity asset bundle fixtures")]
    public void ValidateAgainstUnityPy_CigarNode0_MatchesReferenceJSON()
    {
        // This test would:
        // 1. Load reference JSON generated by scripts/generate_serializedfile_json.py
        // 2. Parse SerializedFile with C#
        // 3. Serialize object metadata to JSON (PathID, ClassID, ByteStart, ByteSize)
        // 4. Compare with reference JSON - must match exactly
        
        string referenceJsonPath = Path.Combine("Fixtures", "Reference", "Cigar_node0_expected.json");
        Assert.True(File.Exists(referenceJsonPath), 
            "Reference JSON not found. Run scripts/generate_serializedfile_json.py to create reference outputs");
    }

    [Fact(Skip = "Requires big-endian test fixture")]
    public void Parse_BigEndianSerializedFile_HandlesEndianness()
    {
        // This test would verify that endianness byte swapping works correctly
        // Requires crafting or obtaining a big-endian SerializedFile (from PS3/Xbox 360/Wii U builds)
        
        string fixturePath = Path.Combine("Fixtures", "BigEndian", "test_bigendian.asset");
        Assert.True(File.Exists(fixturePath), 
            "Big-endian fixture not found. Create synthetic big-endian SerializedFile for testing");
    }

    [Theory(Skip = "Requires version-specific fixtures")]
    [InlineData(14, "v14_test.asset")]  // Unity 5.x
    [InlineData(17, "v17_test.asset")]  // Unity 2017.x
    [InlineData(19, "v19_test.asset")]  // Unity 2019.x
    [InlineData(22, "v22_test.asset")]  // Unity 2022.x
    public void Parse_VariousVersions_ParsesCorrectly(uint version, string filename)
    {
        // This test would verify that different SerializedFile versions parse correctly
        // Unity format has evolved significantly between versions 14-22
        
        string fixturePath = Path.Combine("Fixtures", "Versions", filename);
        Assert.True(File.Exists(fixturePath), 
            $"Version {version} fixture not found: {fixturePath}");
    }

    [Fact(Skip = "Requires MonoBehaviour fixture")]
    public void Parse_MonoBehaviourScripts_ClassID114_ParsesCorrectly()
    {
        // Verify that MonoBehaviour scripts (ClassID 114) with ScriptId hashes parse correctly
        // These are custom scripts attached to GameObjects
        
        string fixturePath = Path.Combine("Fixtures", "MonoBehaviour", "custom_script.asset");
        Assert.True(File.Exists(fixturePath), 
            "MonoBehaviour fixture not found");
    }

    /// <summary>
    /// Example of how to use SerializedFile with BundleFile in practice.
    /// This is a documentation test showing the integration pattern.
    /// </summary>
    [Fact]
    public void ExampleUsage_IntegrateWithBundleFile()
    {
        // This demonstrates the intended usage pattern:
        
        // Step 1: Parse UnityFS bundle
        // using var stream = File.OpenRead("Cigar.hhh");
        // var bundle = BundleFile.Parse(stream);
        
        // Step 2: Extract Node 0 (SerializedFile)
        // var node0 = bundle.Nodes.First(n => n.Path == "CAB-xxx");
        // var node0Data = bundle.ReadNode(node0);
        
        // Step 3: Parse SerializedFile
        // var serializedFile = UnityAssetParser.SerializedFile.SerializedFile.Parse(node0Data.Span);
        
        // Step 4: Check for renderable content (Mesh objects)
        // bool hasRenderable = serializedFile.GetObjectsByClassId(43).Any();
        
        // Step 5: Access specific objects for downstream parsing (e.g., Mesh parser)
        // foreach (var meshObj in serializedFile.GetObjectsByClassId(43))
        // {
        //     var objectData = serializedFile.ReadObjectData(meshObj);
        //     // Pass objectData to Mesh parser
        // }
        
        Assert.True(true, "This is a documentation test showing usage pattern");
    }
}
