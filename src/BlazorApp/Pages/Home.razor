@page "/"
@layout PlannerLayout
@inject DecorationIndexService DecorationIndex
@inject AssetStoreService AssetStore
@inject IJSRuntime JS
@implements IAsyncDisposable

<PageTitle>Outfit Planner</PageTitle>

<section class="planner-grid">
	<aside class="planner-panel planner-slots">
		<div class="planner-panel__title">Slots</div>
		<ul class="planner-slots__list">
			@foreach (var bodyPart in BodyPartGroups)
			{
				<li>
					<button
						class="planner-slot @(activeBodyPart == bodyPart ? "planner-slot--active" : string.Empty)"
						type="button"
						@onclick="() => SelectBodyPartAsync(bodyPart)"
						data-testid="slot-@bodyPart">
						@bodyPart
					</button>
				</li>
			}
		</ul>

		<div class="planner-selection">
			<div class="planner-panel__title">Selected</div>
			<ul class="planner-selection__list">
				@foreach (var bodyPart in BodyPartGroups)
				{
					var selected = GetSelectedEntry(bodyPart);
					<li>@bodyPart: @(selected is null ? "None" : DecorationNameFormatter.GetDisplayName(selected.FilePath))</li>
				}
			</ul>
			<button class="btn btn-outline-secondary" type="button" @onclick="ClearLibraryAsync" disabled="@(isClearingLibrary || DecorationIndex.Entries.Count == 0)" data-testid="clear-library-button">
				@(isClearingLibrary ? "Clearing..." : "Clear library")
			</button>
		</div>
	</aside>

	<section class="planner-panel planner-preview">
		<div class="planner-panel__title">Character Preview</div>
		<div class="planner-viewport">
			<model-viewer
				id="planner-preview-viewer"
				class="planner-model-viewer"
				camera-controls
				auto-rotate
				touch-action="pan-y"
				data-testid="preview-viewer">
			</model-viewer>
			@if (!string.IsNullOrWhiteSpace(previewStatusMessage))
			{
				<div class="planner-preview__message" data-testid="preview-status">@previewStatusMessage</div>
			}
		</div>
	</section>

	<aside class="planner-panel planner-items">
		<div class="planner-panel__title">Items Panel (@DecorationIndex.Entries.Count loaded)</div>
		<div class="planner-items__slot">Slot: @(activeBodyPart ?? "None")</div>

		@if (CurrentBodyPartEntries.Count == 0)
		{
			<div class="planner-item-card planner-item-card--empty">No items for the selected slot.</div>
		}
		else
		{
			@foreach (var entry in CurrentBodyPartEntries)
			{
				var isSelected = IsSelected(entry);
				<button class="planner-item-card planner-item-card--button @(isSelected ? "planner-item-card--selected" : string.Empty)"
					type="button"
					@onclick="() => SelectEntryAsync(entry)"
					data-testid="item-@entry.Sha256">
					<div class="planner-item-card__name">@DecorationNameFormatter.GetDisplayName(entry.FilePath)</div>
					<div class="planner-item-card__meta">@entry.BodyPart • @FormatFileSize(entry.SizeBytes)</div>
				</button>
			}
		}
	</aside>
</section>

<ModsWizard />

@code {
	private const string PreviewElementId = "planner-preview-viewer";
	private readonly Dictionary<string, string> selectedByBodyPart = new(StringComparer.OrdinalIgnoreCase);
	private IJSObjectReference? previewModule;
	private string? activeBodyPart;
	private bool isClearingLibrary;
	private string? previewStatusMessage;

	private IReadOnlyList<string> BodyPartGroups => DecorationIndex.Entries
		.Select(entry => entry.BodyPart)
		.Distinct(StringComparer.OrdinalIgnoreCase)
		.OrderBy(item => item, StringComparer.OrdinalIgnoreCase)
		.ToList();

	private IReadOnlyList<DecorationEntry> CurrentBodyPartEntries =>
		string.IsNullOrWhiteSpace(activeBodyPart)
			? Array.Empty<DecorationEntry>()
			: DecorationIndex.Entries
				.Where(entry => string.Equals(entry.BodyPart, activeBodyPart, StringComparison.OrdinalIgnoreCase))
				.OrderBy(entry => entry.FilePath, StringComparer.OrdinalIgnoreCase)
				.ToList();

	protected override void OnInitialized()
	{
		DecorationIndex.OnChange += HandleDecorationIndexChanged;
	}

	protected override async Task OnInitializedAsync()
	{
		await DecorationIndex.LoadPersistedAsync();
		RefreshSelectionAndStatusFromEntries();
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (!firstRender)
		{
			return;
		}

		previewModule = await JS.InvokeAsync<IJSObjectReference>("import", "./js/previewInterop.js");
		if (!string.IsNullOrWhiteSpace(activeBodyPart))
		{
			await SyncPreviewToCurrentSelectionAsync();
		}
	}

	private DecorationEntry? GetSelectedEntry(string bodyPart)
	{
		if (!selectedByBodyPart.TryGetValue(bodyPart, out var selectedId))
		{
			return null;
		}

		return DecorationIndex.Entries.FirstOrDefault(entry =>
			string.Equals(entry.BodyPart, bodyPart, StringComparison.OrdinalIgnoreCase)
			&& string.Equals(entry.Sha256, selectedId, StringComparison.OrdinalIgnoreCase));
	}

	private bool IsSelected(DecorationEntry entry)
		=> selectedByBodyPart.TryGetValue(entry.BodyPart, out var selectedId)
			&& string.Equals(selectedId, entry.Sha256, StringComparison.OrdinalIgnoreCase);

	private async Task SelectBodyPartAsync(string bodyPart)
	{
		activeBodyPart = bodyPart;
		await SyncPreviewToCurrentSelectionAsync();
	}

	private async Task SelectEntryAsync(DecorationEntry entry)
	{
		selectedByBodyPart[entry.BodyPart] = entry.Sha256;
		activeBodyPart = entry.BodyPart;
		await SyncPreviewToCurrentSelectionAsync();
	}

	private async Task SyncPreviewToCurrentSelectionAsync()
	{
		if (previewModule is null)
		{
			return;
		}

		if (string.IsNullOrWhiteSpace(activeBodyPart))
		{
			await previewModule.InvokeVoidAsync("clearPreview", PreviewElementId);
			previewStatusMessage = "No slot selected.";
			await InvokeAsync(StateHasChanged);
			return;
		}

		var selectedEntry = GetSelectedEntry(activeBodyPart);
		if (selectedEntry is null)
		{
			await previewModule.InvokeVoidAsync("clearPreview", PreviewElementId);
			previewStatusMessage = "Select an item to preview.";
			await InvokeAsync(StateHasChanged);
			return;
		}

		var previewResult = await previewModule.InvokeAsync<PreviewResult>("previewAsset", PreviewElementId, selectedEntry.Sha256);
		previewStatusMessage = previewResult.Success
			? $"Previewing {DecorationNameFormatter.GetDisplayName(selectedEntry.FilePath)}"
			: previewResult.Reason ?? "Preview unavailable for selected item.";
		await InvokeAsync(StateHasChanged);
	}

	private static string FormatFileSize(long bytes)
	{
		const decimal kilo = 1024m;
		const decimal mega = 1024m * 1024m;

		if (bytes >= mega)
		{
			return $"{bytes / mega:0.##} MB";
		}

		return $"{bytes / kilo:0.##} KB";
	}

	private async Task ClearLibraryAsync()
	{
		isClearingLibrary = true;
		await AssetStore.ClearAsync();
		await DecorationIndex.ReloadPersistedAsync();
		selectedByBodyPart.Clear();
		RefreshSelectionAndStatusFromEntries();

		if (previewModule is not null)
		{
			await previewModule.InvokeVoidAsync("clearPreview", PreviewElementId);
		}

		previewStatusMessage = "Library cleared. Load mods to start previewing items.";
		isClearingLibrary = false;
	}

	private void RefreshSelectionAndStatusFromEntries()
	{
		if (BodyPartGroups.Count == 0)
		{
			activeBodyPart = null;
			previewStatusMessage = "Load mods to start previewing items.";
			return;
		}

		if (string.IsNullOrWhiteSpace(activeBodyPart)
			|| !BodyPartGroups.Contains(activeBodyPart, StringComparer.OrdinalIgnoreCase))
		{
			activeBodyPart = BodyPartGroups[0];
		}

		previewStatusMessage = "Select an item to preview.";
	}

	private void HandleDecorationIndexChanged()
	{
		RefreshSelectionAndStatusFromEntries();
		_ = InvokeAsync(async () =>
		{
			await SyncPreviewToCurrentSelectionAsync();
			StateHasChanged();
		});
	}

	public async ValueTask DisposeAsync()
	{
		DecorationIndex.OnChange -= HandleDecorationIndexChanged;

		if (previewModule is null)
		{
			return;
		}

		await previewModule.InvokeVoidAsync("clearPreview", PreviewElementId);
		await previewModule.DisposeAsync();
	}

	private sealed class PreviewResult
	{
		public bool Success { get; set; }
		public string? Reason { get; set; }
	}
}
